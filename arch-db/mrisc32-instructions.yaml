# -*- mode: yaml; tab-width: 2; indent-tabs-mode: nil; -*-
# -----------------------------------------------------------------------------
# Copyright (c) 2021 Marcus Geelnard
#
# This software is provided 'as-is', without any express or implied warranty.
# In no event will the authors be held liable for any damages arising from the
# use of this software.
#
# Permission is granted to anyone to use this software for any purpose,
# including commercial applications, and to alter it and redistribute it
# freely, subject to the following restrictions:
#
#  1. The origin of this software must not be misrepresented; you must not
#     claim that you wrote the original software. If you use this software in a
#     product, an acknowledgment in the product documentation would be
#     appreciated but is not required.
#
#  2. Altered source versions must be plainly marked as such, and must not be
#     misrepresented as being the original software.
#
#  3. This notice may not be removed or altered from any source distribution.
# -----------------------------------------------------------------------------

---
templates:
  # Load/Store instructions.
  type1: &type1
    fmts: [A, C]
    tMode: X
    vModes: [VSS, VSV]
    fold: false
    asmOperands: "{1}, [{2}, {3}]"
    immEnc: I15

  # Bitwise operations (format A + C with bitwise negation).
  type2: &type2
    fmts: [A, C]
    tMode: B
    vModes: [VVS, VVV]
    fold: true
    asmOperands: "{1}, {2}, {3}"
    immEnc: I15HL

  # Regular format A + C instructions.
  type3: &type3
    fmts: [A, C]
    tMode: P
    vModes: [VVS, VVV]
    fold: true
    asmOperands: "{1}, {2}, {3}"
    immEnc: I15HL

  # Regular format A instructions.
  type4: &type4
    fmts: [A]
    tMode: P
    vModes: [VVS, VVV]
    fold: true
    asmOperands: "{1}, {2}, {3}"

  # Regular format B instructions.
  type5: &type5
    fmts: [B]
    tMode: P
    vModes: [VV]
    fold: false
    asmOperands: "{1}, {2}"

  # Regular format D instructions.
  type6: &type6
    fmts: [D]
    tMode: N
    vModes: []
    fold: false
    asmOperands: "{1}, {2}"
    immEnc: I21X4

  # Unconditional branch instructions (format D).
  type7: &type7
    <<: *type6
    immSyntax: "target"

  # Conditional branch instructions (format E).
  type8: &type8
    <<: *type6
    fmts: [E]
    immSyntax: "target"
    immEnc: I18X4

  # Load/store PC-relative (format D).
  type9: &type9
    <<: *type6
    fmts: [D]
    immSyntax: "address@pc"

instructions:
  Load and store:
    LDB:
      <<: *type1
      name: Load signed byte
      descr: >
        Load and sign extend a byte (8 bits).
      pseudo: |
        if V == 10_2 then
          adr = int(b) + int(c) * i * scale
        else
          adr = int(b) + int(c) * scale
        a = int(MEM[adr,1])
      op: 1

    LDH:
      <<: *type1
      name: Load signed half-word
      descr: >
        Load and sign extend a half-word (16 bits).
      pseudo: |
        if V == 10_2 then
          adr = int(b) + int(c) * i * scale
        else
          adr = int(b) + int(c) * scale
        a = int(MEM[adr,2])
      op: 2

    LDW:
      <<: *type1
      name: Load word
      descr: >
        Load a word (32 bits).
      pseudo: |
        if V == 10_2 then
          adr = int(b) + int(c) * i * scale
        else
          adr = int(b) + int(c) * scale
        a = int(MEM[adr,4])
      op: 3

    LDWPC:
      <<: *type9
      name: Load word PC-relative
      descr: >
        Load a word (32 bits) from the address that is formed by adding the
        21-bit signed immediate, multiplied by four, to the current PC.
      pseudo: |
        adr = PC + int(b) * 4
        a = int(MEM[adr,4])
      op: 2

    LDUB:
      <<: *type1
      name: Load unsigned byte
      descr: >
        Load and zero extend a byte (8 bits).
      pseudo: |
        if V == 10_2 then
          adr = int(b) + int(c) * i * scale
        else
          adr = int(b) + int(c) * scale
        a = uint(MEM[adr,1])
      op: 5

    LDUH:
      <<: *type1
      name: Load unsigned half-word
      descr: >
        Load and zero extend a half-word (16 bits).
      pseudo: |
        if V == 10_2 then
          adr = int(b) + int(c) * i * scale
        else
          adr = int(b) + int(c) * scale
        a = uint(MEM[adr,2])
      op: 6

    LDEA:
      <<: *type1
      name: Load effective address
      descr: >
        Load effective address.
      pseudo: |
        if V == 10_2 then
          a = int(b) + int(c) * i * scale
        else
          a = int(b) + int(c) * scale
      note: >
        When the target operand is a vector register, LDEA can be used for
        constructing strides. For instance LDEA V1,Z,#3 will assign the
        vector [0,3,6,9,...] to register V1.
      op: 7

    STB:
      <<: *type1
      name: Store byte
      descr: >
        Store a byte (8 bits).
      pseudo: |
        if V == 10_2 then
          adr = int(b) + int(c) * i * scale
        else
          adr = int(b) + int(c) * scale
        MEM[adr,1] = a
      op: 9

    STH:
      <<: *type1
      name: Store half-word
      descr: >
        Store a half-word (16 bits).
      pseudo: |
        if V == 10_2 then
          adr = int(b) + int(c) * i * scale
        else
          adr = int(b) + int(c) * scale
        MEM[adr,2] = a
      op: 10

    STW:
      <<: *type1
      name: Store word
      descr: >
        Store a word (32 bits).
      pseudo: |
        if V == 10_2 then
          adr = int(b) + int(c) * i * scale
        else
          adr = int(b) + int(c) * scale
        MEM[adr,4] = a
      op: 11

    STWPC:
      <<: *type9
      name: Store word PC-relative
      descr: >
        Store a word (32 bits) to the address that is formed by adding the
        21-bit signed immediate, multiplied by four, to the current PC.
      pseudo: |
        adr = PC + int(b) * 4
        MEM[adr,4] = a
      op: 3

    LDI:
      <<: *type6
      name: Load immediate
      descr: >
        Load immediate value (low or high bits).
      pseudo: |
        a = b
      note: >
        With this instruction it is possible to load signed integer values in
        the range [-524288, 524287].

        It is also possible to load an immediate value that occupies the upper
        bits of a 32-bit word with the lower bits being filled with the LSB of
        the immediate field, making it suitable for loading values and masks
        such as 0x7fffffff and 0x8000ffff.

        This instruction can be used in combination with several instructions
        that take an immediate operand in order to form a full 32-bit
        value or absolute address. Examples of such instructions are OR, LDW
        and JL.

        Another use of this instruction is to load 32-bit floating-point
        values that can be represented with the 19 most significant bits (i.e.
        sign + exponent + 10 bits of mantissa), such as 1.0 (0x3f800000) or
        -255.0 (0xc37f0000).
      op: 6
      immEnc: I21HL

  Bitwise logic:
    AND:
      <<: *type2
      name: Bitwise and
      descr: >
        Compute the bitwise and of two integer operands, with optional negation
        of the source operands.
      pseudo: |
        if T == 00_2 then
          a = b & c
        else if T == 01_2 then
          a = b & ~c
        else if T == 10_2 then
          a = ~b & c
        else if T == 11_2 then
          a = ~b & ~c
      op: 16

    OR:
      <<: *type2
      name: Bitwise or
      descr: >
        Compute the bitwise or of two integer operands, with optional negation
        of the source operands.
      pseudo: |
        if T == 00_2 then
          a = b | c
        else if T == 01_2 then
          a = b | ~c
        else if T == 10_2 then
          a = ~b | c
        else if T == 11_2 then
          a = ~b | ~c
      op: 17

    XOR:
      <<: *type2
      name: Bitwise exclusive or
      descr: >
        Compute the bitwise exclusive or of two integer operands, with optional
        negation of the source operands.
      pseudo: |
        if T == 00_2 then
          a = b ^ c
        else if T == 01_2 then
          a = b ^ ~c
        else if T == 10_2 then
          a = ~b ^ c
        else if T == 11_2 then
          a = ~b ^ ~c
      op: 18

    EBF:
      <<: *type3
      name: Extract bit field
      descr: >
        Extract a bit field from the first source operand, sign-extend it, and
        store it in the destination operand. The bit field (offset, width) is
        defined by the second source operand.

        In word mode, bits <12:8> of the second source operand describe the bit
        field width, and bits <4:0> describe the bit field offset.

        In half-word mode, bits <11:8> of the second source operand describe
        the bit field width, and bits <3:0> describe the bit field offset.

        In byte mode, bits <6:4> of the second source operand describe the bit
        field width, and bits <2:0> describe the bit field offset.

        If the value of the bit field width descriptor is zero (0), the width
        is interpreted as being the full width of the chunk.

        The first source operand is sign extended up to the number of bits
        required by the bit field.
      note: >
        When the bit field width descriptor is all zeros (specifying the full
        width of the chunk), this instruction operates as an arithmetic shift
        right instruction.

        ASR is a valid assembler alias for EBF.
      pseudo: |
        o = uint(c & (bits-1))
        if bits == 8 then
          w = uint((c >> 4) & (bits-1))
        else
          w = uint((c >> 8) & (bits-1))
        if w == 0 then
          w = bits
        // Note: b is sign-extended up to o+w
        // bits if o+w > bits.
        a = int(b<o+w-1:o>)
      op: 19
      immSyntax: "<offs:width>"

    EBFU:
      <<: *type3
      name: Extract bit field unsigned
      descr: >
        Extract a bit field from the first source operand, zero-extend it, and
        store it in the destination operand. The bit field (offset, width) is
        defined by the second source operand.

        In word mode, bits <12:8> of the second source operand describe the bit
        field width, and bits <4:0> describe the bit field offset.

        In half-word mode, bits <11:8> of the second source operand describe
        the bit field width, and bits <3:0> describe the bit field offset.

        In byte mode, bits <6:4> of the second source operand describe the bit
        field width, and bits <2:0> describe the bit field offset.

        If the value of the bit field width descriptor is zero (0), the width
        is interpreted as being the full width of the chunk.

        The first source operand is zero extended up to the number of bits
        required by the bit field.
      note: >
        When the bit field width descriptor is all zeros (specifying the full
        width of the chunk), this instruction operates as a logic shift right
        instruction.

        LSR is a valid assembler alias for EBFU.
      pseudo: |
        o = uint(c & (bits-1))
        if bits == 8 then
          w = uint((c >> 4) & (bits-1))
        else
          w = uint((c >> 8) & (bits-1))
        if w == 0 then
          w = bits
        a = (b >> o) & ones(w)
      op: 20
      immSyntax: "<offs:width>"

    MKBF:
      <<: *type3
      name: Make bit field
      descr: >
        Extract a bit field from the lower bits of the first source operand,
        shift it to the left, and store it in the destination operand.

        The bit field (offset, width) is defined by the second source operand.

        In word mode, bits <12:8> of the second source operand describe the bit
        field width, and bits <4:0> describe the bit field offset.

        In half-word mode, bits <11:8> of the second source operand describe
        the bit field width, and bits <3:0> describe the bit field offset.

        In byte mode, bits <6:4> of the second source operand describe the bit
        field width, and bits <2:0> describe the bit field offset.

        If the value of the bit field width descriptor is zero (0), the width
        is interpreted as being the full width of the chunk.
      note: >
        When the bit field width descriptor is all zeros (specifying the full
        width of the chunk), this instruction operates as a logic shift left
        instruction.

        LSL is a valid assembler alias for MKBF.
      pseudo: |
        o = uint(c & (bits-1))
        if bits == 8 then
          w = uint((c >> 4) & (bits-1))
        else
          w = uint((c >> 8) & (bits-1))
        if w == 0 then
          w = bits
        a = (b & ones(w)) << o
      op: 21
      immSyntax: "<offs:width>"

    IBF:
      <<: *type3
      name: Insert bit field
      descr: >
        Extract a bit field from the lower bits of the first source operand,
        shift it to the left, and insert it in the destination operand.

        The bit field (offset, width) is defined by the second source operand.

        In word mode, bits <12:8> of the second source operand describe the bit
        field width, and bits <4:0> describe the bit field offset.

        In half-word mode, bits <11:8> of the second source operand describe
        the bit field width, and bits <3:0> describe the bit field offset.

        In byte mode, bits <6:4> of the second source operand describe the bit
        field width, and bits <2:0> describe the bit field offset.

        If the value of the bit field width descriptor is zero (0), the width
        is interpreted as being the full width of the chunk.
      pseudo: |
        o = uint(c & (bits-1))
        if bits == 8 then
          w = uint((c >> 4) & (bits-1))
        else
          w = uint((c >> 8) & (bits-1))
        if w == 0 then
          w = bits
        a = (a & ~(ones(w) << o)) |
            ((b & ones(w)) << o)
      op: 47
      immSyntax: "<offs:width>"

    SEL:
      <<: *type3
      name: Bitwise select
      descr: >
        Bitwise select.
      pseudo: |
        if T == 00_2 then
          a = (b & a) | (c & ~a)
        else if T == 01_2 then
          a = (c & a) | (b & ~a)
        else if T == 10_2 then
          a = (a & b) | (c & ~b)
        else if T == 11_2 then
          a = (c & b) | (a & ~b)
      op: 46
      tMode: S  # SEL uses a special kind of interpretation of the T field.

  Integer arithmetic:
    ADD:
      <<: *type3
      name: Add
      descr: >
        Compute the sum of two integer operands.
      pseudo: |
        a = int(b) + int(c)
      op: 22

    SUB:
      <<: *type3
      name: Subtract
      descr: >
        Compute the difference of two integer operands.
      op: 23
      pseudo: |
        a = int(c) - int(b)
      # The source operands are reversed for SUB.
      asmOperands: "{1}, {3}, {2}"
      note: >
        The instruction actually subtracts the first source operand from the
        second source operand. However, in the assembler syntax the order of
        the source operands is reversed compared to how the operands are
        encoded in the instruction word, in order to make the assembler syntax
        more natural.

        The advantage is that it is possible to subtract a register operand
        from an immediate operand (subtracting an immediate operand from a
        register operand can be implemented with the ADD instruction, using a
        negated immediate operand).

    MUL:
      <<: *type3
      name: Multiply
      descr: >
        Compute the product of two integer operands.
      pseudo: |
        a = int(b) * int(c)
      op: 39

    MADD:
      <<: *type3
      name: Multiply and add
      descr: >
        Compute the product of two integer operands, and add the result to a
        third integer operand.
      pseudo: |
        a = int(a) + int(b) * int(c)
      op: 44

    MULHI:
      <<: *type4
      name: Signed multiply high
      descr: >
        Compute the upper part of the product of two signed integer operands.
      pseudo: |
        a = (int(b) * int(c)) >> bits
      op: 48

    MULHIU:
      <<: *type4
      name: Unsigned multiply high
      descr: >
        Compute the upper part of the product of two unsigned integer
        operands.
      pseudo: |
        a = (uint(b) * uint(c)) >> bits
      op: 49

    DIV:
      <<: *type3
      name: Signed divide
      descr: >
        Compute the quotient of two signed integer operands.
      pseudo: |
        a = int(b) / int(c)
      op: 40

    DIVU:
      <<: *type3
      name: Unsigned divide
      descr: >
        Compute the quotient of two unsigned integer operands.
      pseudo: |
        a = uint(b) / uint(c)
      op: 41

    REM:
      <<: *type3
      name: Signed remainder
      descr: >
        Compute the modulo of two signed integer operands.
      pseudo: |
        a = int(b) % int(c)
      op: 42

    REMU:
      <<: *type3
      name: Unsigned remainder
      descr: >
        Compute the modulo of two unsigned integer operands.
      pseudo: |
        a = uint(b) % uint(c)
      op: 43

    MIN:
      <<: *type3
      name: Signed minimum
      descr: >
        Return the minimum value of two signed integer operands.
      pseudo: |
        a = min(int(b), int(c))
      op: 24

    MAX:
      <<: *type3
      name: Signed maxiumum
      descr: >
        Return the maximum value of two signed integer operands.
      pseudo: |
        a = max(int(b), int(c))
      op: 25

    MINU:
      <<: *type3
      name: Unsigned minimum
      descr: >
        Return the minimum value of two unsigned integer operands.
      pseudo: |
        a = min(uint(b), uint(c))
      op: 26

    MAXU:
      <<: *type3
      name: Unsigned maximum
      descr: >
        Return the maximum value of two unsigned integer operands.
      pseudo: |
        a = max(uint(b), uint(c))
      op: 27

    ADDPC:
      <<: *type6
      name: Add PC and immediate
      descr: >
        Compute the sum of the current PC and an immediate operand.
      pseudo: |
        a = int(PC) + int(b)
      op: 4
      immSyntax: "target@pc"

    ADDPCHI:
      <<: *type6
      name: Add PC and high immediate
      descr: >
        Compute the sum of the current PC and an immediate operand.
      pseudo: |
        a = int(PC) + int(b)
      note: >
        This instruction can be used in combination with several instructions
        that take an immediate operand in order to form a full 32-bit
        PC-relative offset. Examples of such instructions are ADD, LDH and JL.
      op: 5
      immSyntax: "target@pchi"
      immEnc: I21H

  Integer comparison:
    SEQ:
      <<: *type3
      name: Set if equal
      descr: >
        Compare two integer operands, and set all bits of the result to 1 if
        the operands are equal, otherwise set all bits of the result to 0.
      pseudo: |
        if b == c then
          a = ones(bits)
        else
          a = zeros(bits)
      op: 28

    SNE:
      <<: *type3
      name: Set if not equal
      descr: >
        Compare two integer operands, and set all bits of the result to 1 if
        the operands are not equal, otherwise set all bits of the result to
        0.
      pseudo: |
        if b != c then
          a = ones(bits)
        else
          a = zeros(bits)
      op: 29

    SLT:
      <<: *type3
      name: Set if less than
      descr: >
        Compare two signed integer operands, and set all bits of the result
        to 1 if the first operand is less than the second operand, otherwise
        set all bits of the result to 0.
      pseudo: |
        if int(b) < int(c) then
          a = ones(bits)
        else
          a = zeros(bits)
      op: 30

    SLTU:
      <<: *type3
      name: Set if less than unsigned
      descr: >
        Compare two unsigned integer operands, and set all bits of the result
        to 1 if the first operand is less than the second operand, otherwise
        set all bits of the result to 0.
      pseudo: |
        if uint(b) < uint(c) then
          a = ones(bits)
        else
          a = zeros(bits)
      op: 31

    SLE:
      <<: *type3
      name: Set if less than or equal
      descr: >
        Compare two signed integer operands, and set all bits of the result
        to 1 if the first operand is less than or equal to the second
        operand, otherwise set all bits of the result to 0.
      pseudo: |
        if int(b) <= int(c) then
          a = ones(bits)
        else
          a = zeros(bits)
      op: 32

    SLEU:
      <<: *type3
      name: Set if less than or equal unsigned
      descr: >
        Compare two unsigned integer operands, and set all bits of the result
        to 1 if the first operand is less than or equal to the second
        operand, otherwise set all bits of the result to 0.
      pseudo: |
        if uint(b) <= uint(c) then
          a = ones(bits)
        else
          a = zeros(bits)
      op: 33

  Branch:
    BZ:
      <<: *type8
      name: Branch if zero
      descr: >
        Branch to the PC-relative target if all bits of the first source
        operand are zero.
      pseudo: |
        if a == zeros(32) then
          PC = int(PC) + int(b)
      op: 0

    BNZ:
      <<: *type8
      name: Branch if not zero
      descr: >
        Branch to the PC-relative target if at least one of the bits of the
        first source operand is non-zero.
      pseudo: |
        if a != zeros(32) then
          PC = int(PC) + int(b)
      op: 1

    BS:
      <<: *type8
      name: Branch if set
      descr: >
        Branch to the PC-relative target if all bits of the first source
        operand are non-zero.
      pseudo: |
        if a == ones(32) then
          PC = int(PC) + int(b)
      op: 2

    BNS:
      <<: *type8
      name: Branch if not set
      descr: >
        Branch to the PC-relative target if at least one of the bits of the
        first source operand is zero.
      pseudo: |
        if a != ones(32) then
          PC = int(PC) + int(b)
      op: 3

    BLT:
      <<: *type8
      name: Branch if less than
      descr: >
        Branch to the PC-relative target if the first source operand is a
        signed integer value that is less than zero.
      pseudo: |
        if int(a) < 0 then
          PC = int(PC) + int(b)
      op: 4

    BGE:
      <<: *type8
      name: Branch if greater than or equal
      descr: >
        Branch to the PC-relative target if the first source operand is a
        signed integer value that is greater than or equal to zero.
      pseudo: |
        if int(a) >= 0 then
          PC = int(PC) + int(b)
      op: 5

    BLE:
      <<: *type8
      name: Branch if less than or equal
      descr: >
        Branch to the PC-relative target if the first source operand is a
        signed integer value that is less than or equal to zero.
      pseudo: |
        if int(a) <= 0 then
          PC = int(PC) + int(b)
      op: 6

    BGT:
      <<: *type8
      name: Branch if greater than
      descr: >
        Branch to the PC-relative target if the first source operand is a
        signed integer value that is greater than zero.
      pseudo: |
        if int(a) > 0 then
          PC = int(PC) + int(b)
      op: 7

    J:
      <<: *type7
      name: Jump
      descr: >
        Jump to the target address that is formed by computing the sum of the
        register operand and the immediate operand.

        As a special case, the register operand can be the program counter
        (PC), which is encoded as register number 31. This also means that the
        VL register can not be used as the register operand.
      pseudo: |
        PC = int(a) + int(b)
      note: >
        If the register operand is PC, a PC-relative branch with an effective
        range of +/-4MiB is performed. To extend the range to the full address
        space, use J in combination with a preceding ADDPCHI.

        If the register operand is Z, an absolute branch is performed.
        Possible target addresses are 0x00000000 to 0x003FFFFC and 0xFFC00000
        to 0xFFFFFFFC. To extend the range to the full address space, use J in
        combination with a preceding LDI.

        If the register operand is LR and the immediate value is zero, the
        operation will return the program flow to the caller (RET is an alias
        for J LR, #0).
      op: 0

    JL:
      <<: *type7
      name: Jump and link
      descr: >
        Jump and link. The current value of PC plus four is stored in the LR
        register, and the new PC is set to the target address that is formed by
        computing the sum of the register operand and immediate operand.

        As a special case, the register operand can be the program counter
        (PC), which is encoded as register number 31. This also means that the
        VL register can not be used as the register operand.
      pseudo: |
        adr = int(a) + int(b)
        LR = int(PC) + 4
        PC = adr
      note: >
        If the register operand is PC, a PC-relative branch with an effective
        range of +/-4MiB is performed. To extend the range to the full address
        space, use JL in combination with a preceding ADDPCHI.

        If the register operand is Z, an absolute branch is performed.
        Possible target addresses are 0x00000000 to 0x003FFFFC and 0xFFC00000
        to 0xFFFFFFFC. To extend the range to the full address space, use JL
        in combination with a preceding LDI.
      op: 1

  Floating-point arithmetic:
    FADD:
      <<: *type4
      name: Floating-point add
      descr: >
        Compute the sum of two floating-point operands.
      pseudo: |
        a = float(b) + float(c)
      op: 80
      requires: ["FM"]

    FSUB:
      <<: *type4
      name: Floating-point subtract
      descr: >
        Compute the difference of two floating-point operands.
      pseudo: |
        a = float(b) - float(c)
      op: 81
      requires: ["FM"]

    FMUL:
      <<: *type4
      name: Floating-point multiply
      descr: >
        Compute the product of two floating-point operands.
      pseudo: |
        a = float(b) * float(c)
      op: 82
      requires: ["FM"]

    FDIV:
      <<: *type4
      name: Floating-point divide
      descr: >
        Compute the quotient of two floating-point operands.
      pseudo: |
        a = float(b) / float(c)
      op: 83
      requires: ["FM"]

    FMIN:
      <<: *type4
      name: Floating-point minimum
      descr: >
        Return the minimum value of two floating-point operands.
      pseudo: |
        a = min(float(b), float(c))
      op: 64
      requires: ["FM"]

    FMAX:
      <<: *type4
      name: Floating-point maximum
      descr: >
        Return the maximum value of two floating-point operands.
      pseudo: |
        a = max(float(b), float(c))
      op: 65
      requires: ["FM"]

  Floating-point comparison:
    FSEQ:
      <<: *type4
      name: Floating-point set if equal
      descr: >
        Compare two floating-point operands, and set all bits of the result to
        1 if the first operand is equal to the second operand, otherwise set
        all bits of the result to 0.
      pseudo: |
        if float(b) == float(c) then
          a = ones(bits)
        else
          a = zeros(bits)
      op: 66
      requires: ["FM"]

    FSNE:
      <<: *type4
      name: Floating-point set if not equal
      descr: >
        Compare two floating-point operands, and set all bits of the result to
        1 if the first operand is not equal to the second operand, otherwise
        set all bits of the result to 0.
      pseudo: |
        if float(b) != float(c) then
          a = ones(bits)
        else
          a = zeros(bits)
      op: 67
      requires: ["FM"]

    FSLT:
      <<: *type4
      name: Floating-point set if less than
      descr: >
        Compare two floating-point operands, and set all bits of the result to
        1 if the first operand is less than the second operand, otherwise set
        all bits of the result to 0.
      pseudo: |
        if float(b) < float(c) then
          a = ones(bits)
        else
          a = zeros(bits)
      op: 68
      requires: ["FM"]

    FSLE:
      <<: *type4
      name: Floating-point set if less than or equal
      descr: >
        Compare two floating-point operands, and set all bits of the result to
        1 if the first operand is less than or equal to the second operand,
        otherwise set all bits of the result to 0.
      pseudo: |
        if float(b) <= float(c) then
          a = ones(bits)
        else
          a = zeros(bits)
      op: 69
      requires: ["FM"]

    FSUNORD:
      <<: *type4
      name: Floating-point set if unordered
      descr: >
        Set all bits of the result to 1 if any of the source operands are
        undordered (i.e. NaN), otherwise set all bits of the result to 0.
      pseudo: |
        if isnan(b) || isnan(c) then
          a = ones(bits)
        else
          a = zeros(bits)
      op: 70
      requires: ["FM"]

    FSORD:
      <<: *type4
      name: Floating-point set if ordered
      descr: >
        Set all bits of the result to 1 if both of the source operands are
        ordered (i.e. non-NaN), otherwise set all bits of the result to 0.
      pseudo: |
        if !isnan(b) && !isnan(c) then
          a = ones(bits)
        else
          a = zeros(bits)
      op: 71
      requires: ["FM"]

  Floating-point conversion:
    ITOF:
      <<: *type4
      name: Signed integer to floating-point
      descr: >
        Convert a signed integer value to a floating-point value. The exponent
        of the resulting floating-point value is subtracted by the integer
        offset provided by the second source operand before storing the final
        floating-point value in the destination operand.
      todo: Define pseudocode.
      op: 72
      requires: ["FM"]

    UTOF:
      <<: *type4
      name: Unsigned integer to floating-point
      descr: >
        Convert an unsigned integer value to a floating-point value. The
        exponent of the resulting floating-point value is subtracted by the
        integer offset provided by the second source operand before storing the
        final floating-point value in the destination operand.
      todo: Define pseudocode.
      op: 73
      requires: ["FM"]

    FTOI:
      <<: *type4
      name: Floating-point to signed integer
      descr: >
        Convert a floating-point value to a signed integer value, without
        rounding. The integer offset provided by the second source operand is
        added to the floating-point exponent before the conversion.
      todo: Define pseudocode.
      op: 74
      requires: ["FM"]

    FTOU:
      <<: *type4
      name: Floating-point to unsigned integer
      descr: >
        Convert a floating-point value to an unsigned integer value, without
        rounding. The integer offset provided by the second source operand is
        added to the floating-point exponent before the conversion.
      todo: Define pseudocode.
      op: 75
      requires: ["FM"]

    FTOIR:
      <<: *type4
      name: Floating-point to signed integer with rounding
      descr: >
        Convert a floating-point value to a signed integer value, with
        rounding. The integer offset provided by the second source operand is
        added to the floating-point exponent before the conversion.
      todo: Define pseudocode.
      op: 76
      requires: ["FM"]

    FTOUR:
      <<: *type4
      name: Floating-point to unsigned integer with rounding
      descr: >
        Convert a floating-point value to an unsigned integer value, with
        rounding. The integer offset provided by the second source operand is
        added to the floating-point exponent before the conversion.
      todo: Define pseudocode.
      op: 77
      requires: ["FM"]

  Saturating and halving arithmetic:
    ADDS:
      <<: *type4
      name: Signed add with saturation
      descr: >
        Compute the saturated sum of two signed integer operands.
      pseudo: |
        a = sat(int(b) + int(c), bits)
      op: 96
      requires: ["SM"]

    ADDSU:
      <<: *type4
      name: Unsigned add with saturation
      descr: >
        Compute the saturated sum of two unsigned integer operands.
      pseudo: |
        a = satu(uint(b) + uint(c), bits)
      op: 97
      requires: ["SM"]

    ADDH:
      <<: *type4
      name: Signed half add
      descr: >
        Compute the half sum of two signed integer operands.
      pseudo: |
        a = (int(b) + int(c)) >>s 1
      op: 98
      requires: ["SM"]

    ADDHU:
      <<: *type4
      name: Unsigned half add
      descr: >
        Compute the half sum of two unsigned integer operands.
      pseudo: |
        a = (uint(b) + uint(c)) >> 1
      op: 99
      requires: ["SM"]

    ADDHR:
      <<: *type4
      name: Signed half add with rounding
      descr: >
        Compute the rounded half sum of two signed integer operands.
      pseudo: |
        a = (int(b) + int(c) + 1) >>s 1
      op: 100
      requires: ["SM"]

    ADDHUR:
      <<: *type4
      name: Unsigned half add with rounding
      descr: >
        Compute the runded half sum of two unsigned integer operands.
      pseudo: |
        a = (uint(b) + uint(c) + 1) >> 1
      op: 101
      requires: ["SM"]

    SUBS:
      <<: *type4
      name: Signed subtract with saturation
      descr: >
        Compute the saturated difference of two signed integer operands.
      pseudo: |
        a = sat(int(b) - int(c), bits)
      op: 102
      requires: ["SM"]

    SUBSU:
      <<: *type4
      name: Unsigned subtract with saturation
      descr: >
        Compute the saturated difference of two unsigned integer operands.
      pseudo: |
        a = satu(uint(b) - uint(c), bits)
      op: 103
      requires: ["SM"]

    SUBH:
      <<: *type4
      name: Signed half subtract
      descr: >
        Compute the half difference of two signed integer operands.
      pseudo: |
        a = (int(b) - int(c)) >>s 1
      op: 104
      requires: ["SM"]

    SUBHU:
      <<: *type4
      name: Unsigned half subtract
      descr: >
        Compute the half difference of two unsigned integer operands.
      pseudo: |
        a = (uint(b) - uint(c)) >> 1
      op: 105
      requires: ["SM"]

    SUBHR:
      <<: *type4
      name: Signed half subtract with rounding
      descr: >
        Compute the rounded half difference of two signed integer operands.
      pseudo: |
        a = (int(b) - int(c) + 1) >>s 1
      op: 106
      requires: ["SM"]

    SUBHUR:
      <<: *type4
      name: Unsigned half subtract with rounding
      descr: >
        Compute the rounded half difference of two unsigned integer operands.
      pseudo: |
        a = (uint(b) - uint(c) + 1) >> 1
      op: 107
      requires: ["SM"]

    MULQ:
      <<: *type4
      name: Multiply Q-numbers
      descr: >
        Compute the product of two fixed point operands, with saturation.
      pseudo: |
        prod = int(b) * int(c)
        a = sat(prod >>s (bits-1), bits)
      op: 50
      requires: ["SM"]

    MULQR:
      <<: *type4
      name: Multiply Q-numbers with rounding
      descr: >
        Compute the rounded product of two fixed point operands, with
        saturation.
      pseudo: |
        prod = int(b) * int(c) + 1<<(bits-2)
        a = sat(prod >>s (bits-1), bits)
      op: 51
      requires: ["SM"]

  Packing and unpacking:
    PACK:
      <<: *type4
      name: Pack
      descr: >
        Pack the lower parts of two integer operands.
      pseudo: |
        a = (b << (bits/2)) |
            (c & ones(bits/2))
      op: 58
      requires: ["PM"]

    PACKHI:
      <<: *type4
      name: Pack high
      descr: >
        Pack the higher parts of two integer operands.
      pseudo: |
        a = (b & ~ones(bits/2)) |
            (c >> (bits/2))
      op: 61
      requires: ["PM"]

    PACKS:
      <<: *type4
      name: Signed pack with saturation
      descr: >
        Saturate and pack the lower parts of two signed integer operands.
      pseudo: |
        hi = sat(int(b), bits/2) & ones(bits/2)
        lo = sat(int(c), bits/2) & ones(bits/2)
        a = (hi << (bits/2)) | lo
      op: 59
      requires: ["SM", "PM"]

    PACKSU:
      <<: *type4
      name: Unsigned pack with saturation
      descr: >
        Saturate and pack the lower parts of two unsigned integer operands.
      pseudo: |
        hi = satu(uint(b), bits/2)
        lo = satu(uint(c), bits/2)
        a = (hi << (bits/2)) | lo
      op: 60
      requires: ["SM", "PM"]

    PACKHIR:
      <<: *type4
      name: Signed pack high with rounding
      descr: >
        Round and pack the higher parts of two signed integer operands.
      pseudo: |
        hi = sat(int(b) + 1<<(bits/2-1), bits)
        lo = sat(int(c) + 1<<(bits/2-1), bits)
        a = (hi & ~ones(bits/2)) |
            (lo >> (bits/2))
      op: 62
      requires: ["SM", "PM"]

    PACKHIUR:
      <<: *type4
      name: Unsigned pack high with rounding
      descr: >
        Round and pack the higher parts of two unsigned integer operands.
      pseudo: |
        hi = satu(uint(b) + 1<<(bits/2-1), bits)
        lo = satu(uint(c) + 1<<(bits/2-1), bits)
        a = (hi & ~ones(bits/2)) |
            (lo >> (bits/2))
      op: 63
      requires: ["SM", "PM"]

    FPACK:
      <<: *type4
      name: Floating-point pack
      descr: >
        Convert and pack two floating-point operands into a single operand.

        The precision of the two source operands are halved. The first source
        operand is packed and stored in the upper half of the destination
        operand, and the second source operand is packed and stored in the
        lower half of the destination operand.
      todo: Define pseudocode.
      tMode: PH  # Only packed half-word is supported
      op: 78
      requires: ["FM", "PM"]

    FUNPL:
      <<: *type5
      name: Floating-point unpack low
      descr: >
        Unpack the low half of a packed floating-point pair. The preicison of
        the unpacked source floating-point value is doubled and stored in the
        destination operand.
      todo: Define pseudocode.
      tMode: PH  # Only packed half-word is supported
      op: 125
      fn: 0
      requires: ["FM", "PM"]

    FUNPH:
      <<: *type5
      name: Floating-point unpack high
      descr: >
        Unpack the high half of a packed floating-point pair. The preicison of
        the unpacked source floating-point value is doubled and stored in the
        destination operand.
      todo: Define pseudocode.
      tMode: PH  # Only packed half-word is supported
      op: 125
      fn: 1
      requires: ["FM", "PM"]

  # TODO(m): Find better categories for these instructions.
  Miscellaneous:
    XCHGSR:
      <<: *type2
      name: Exchange system register
      descr: >
        First move the value of the system register given by the third source
        operand to the destination operand, unless the destination operand is
        the Z register.

        Then move the value of the second source operand to the system register
        given by the third source operand, unless the first source operand is
        the Z register.
      pseudo: |
        a = SR[c]
        if Rb != 00000_2 then
          SR[c] = b
      op: 36
      tMode: N
      fold: false

    SHUF:
      <<: *type2
      name: Shuffle bytes
      descr: >
        Shuffle bytes with optional zero- or sign-extension.

        The bytes of the second operand are shuffled according to the 13-bit
        control word in the third operand, and the result is stored in the
        the first operand.

        Bit 12 of the control word determines the sign mode: 1 = sign fill,
        0 = zero fill.

        Bits 0-1 give the source byte index for destination byte 0, and
        bit 2 gives the fill mode (0 = verbatim copy, 1 = fill).

        Likewise, bits 3-5 define destination byte 1, bits 6-8 define
        destination byte 2 and bits 9-11 define destination byte 3.

        When the fill mode is 0, the source byte is copied to the destination
        byte. When the fill mode is 1, the destination byte is filled with the
        most significant bit of the source byte if the sign mode is 1, or zeros
        if the sign mode is 0.

        Note: Byte 0 is the least significant byte (bits 0-7) and byte 3 is the
        most significant byte (bits 24-31).
      pseudo: |
        sign = c<12>
        for k in 0 to 3
          fill = c<k*3+2>
          idx = uint(c<k*3+1:k*3>)
          byte = b<8*idx+7:8*idx>
          if fill == 1 then
            if sign & byte<7> == 1 then
              byte = ones(8)
            else
              byte = zeros(8)
          a<8*k+7:8*k> = byte
      note: >
        The instruction can be used for several different common tasks, such as
        zero- and sign-extension of integer bytes and half-words, unpacking of
        byte-aligend fields within a word, applying byte masks (e.g. bitwise
        and with 0x00ff00ff) and/or changing the byte order (e.g. for
        conversion between big and little endian formats or different RGBA
        color formats).
      op: 34
      tMode: N  # SHUF does not have any T mode

    REV:
      <<: *type5
      name: Reverse bits
      descr: >
        Reverse the bits of the source operand.
      pseudo: |
        for k in 0 to bits-1
          a<bits-1-k> = b<k>
      op: 124
      fn: 0

    CLZ:
      <<: *type5
      name: Count leading zeros
      descr: >
        Count the number of leading zero bits in the source operand.
      pseudo: |
        a = 0
        for k in bits-1 downto 0
          if b<k> == 1 then
            break
          a = int(a) + 1
      op: 124
      fn: 1

    POPCNT:
      <<: *type5
      name: Population count
      descr: >
        Count the number of non-zero bits in the source operand.
      pseudo: |
        a = 0
        for k in 0 to bits-1
          if b<k> == 1 then
            a = int(a) + 1
      op: 124
      fn: 2
